"use strict";(globalThis.webpackChunkflowra_docs=globalThis.webpackChunkflowra_docs||[]).push([[43],{8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var r=n(6540);const i={},t=r.createContext(i);function o(e){const s=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:s},e.children)}},9878:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"architecture/service-container","title":"Service Container","description":"Flowra resolves dependencies through a container with scoped module registrations.","source":"@site/docs/architecture/service-container.mdx","sourceDirName":"architecture","slug":"/architecture/service-container","permalink":"/docs/architecture/service-container","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Service Container","description":"Flowra resolves dependencies through a container with scoped module registrations."},"sidebar":"docsSidebar","previous":{"title":"Request Lifecycle","permalink":"/docs/architecture/request-lifecycle"},"next":{"title":"Modules","permalink":"/docs/architecture/modules"}}');var i=n(4848),t=n(8453);const o={title:"Service Container",description:"Flowra resolves dependencies through a container with scoped module registrations."},c=void 0,l={},a=[{value:"How it works",id:"how-it-works",level:2},{value:"Module scopes",id:"module-scopes",level:2},{value:"Container API highlights",id:"container-api-highlights",level:2}];function d(e){const s={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"Flowra uses a lightweight container that supports plain functions, values, and Awilix-style resolvers. It keeps dependency resolution explicit and testable."}),"\n",(0,i.jsx)(s.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"container.register(name, factory)"})," registers a dependency."]}),"\n",(0,i.jsxs)(s.li,{children:["Dependencies are ",(0,i.jsx)(s.strong,{children:"singletons by default"})," unless configured otherwise."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"container.createScope(prefix)"})," creates a namespaced scope for modules."]}),"\n",(0,i.jsx)(s.li,{children:"Scopes can register nested objects, which become resolved as dot-notation keys."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"module-scopes",children:"Module scopes"}),"\n",(0,i.jsxs)(s.p,{children:["Modules are registered under the ",(0,i.jsx)(s.code,{children:"modules.<name>"})," namespace. For example, the Users module registers:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="app/Modules/Users/users.container.js"',children:"const { asClass, asValue } = require('awilix');\nconst UsersService = require('./Users.service');\nconst UsersController = require('./Users.controller');\nconst registerUsersRoutes = require('./users.routes');\n\nmodule.exports = (scope) => {\n  scope.register({\n    services: {\n      main: asClass(UsersService).singleton(),\n    },\n    controllers: {\n      main: asClass(UsersController).singleton(),\n    },\n    routes: asValue(registerUsersRoutes),\n  });\n\n  scope.registerAlias('usersController', 'controllers.main');\n};\n"})}),"\n",(0,i.jsx)(s.p,{children:"The container exposes these with dot notation:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"const controller = container.resolve('modules.users.controllers.main');\n"})}),"\n",(0,i.jsx)(s.h2,{id:"container-api-highlights",children:"Container API highlights"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"register()"})," accepts a string + factory or a nested object."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"resolve()"})," throws if a dependency is missing, which keeps errors visible."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"createScope()"})," builds grouped accessors like ",(0,i.jsx)(s.code,{children:"modules.users.services"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"cradle"})," provides a convenient proxy for resolved services."]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{title:"Testing",type:"tip",children:(0,i.jsx)(s.p,{children:"Because dependencies are explicit, you can swap implementations by registering mocks in a test-only container scope."})})]})}function u(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);