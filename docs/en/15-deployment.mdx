---
id: deployment
slug: /deployment/guide
sidebar_position: 15
---

# Deployment Guide

## Build for production
1. Install dependencies using the locked package manager: `npm ci`.
2. Compile TypeScript: `npm run build` (outputs to `dist/`).
3. Copy environment files (`.env.production`) and ensure secrets are injected at runtime.
4. Run database migrations before starting the app: `npx flowra migrate`.

## Environment configuration
- `APP_ENV` – environment name (`production`, `staging`).
- `APP_PORT` – HTTP port (default `3000`).
- `LOG_LEVEL` – `info` for production, `debug` for staging.
- `DB_*` – database credentials (see [Knex setup](/docs/data/knex-setup)).
- `TRUST_PROXY` – set `true` when running behind a reverse proxy.

## Process manager
Use a supervisor like PM2, systemd, or Docker to keep the app alive:

```bash
pm2 start dist/main/bootstrap.js --name flowra-api --env production
```

PM2 ecosystem file example:

```js
module.exports = {
  apps: [
    {
      name: 'flowra-api',
      script: 'dist/main/bootstrap.js',
      env: {
        NODE_ENV: 'production',
        APP_ENV: 'production',
      },
    },
  ],
};
```

## Docker deployment
```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
RUN npm run build
CMD ["node", "dist/main/bootstrap.js"]
```

Run with environment variables:

```bash
docker build -t flowra-api .
docker run -p 3000:3000 --env-file .env.production flowra-api
```

## Logging & monitoring
- Forward stdout/stderr to your logging stack (ELK, Datadog, CloudWatch).
- Include request IDs by enabling the request logging middleware in `core/http/middleware/logger.middleware.ts`.
- Emit custom metrics using `core/events` and ship them to Prometheus or StatsD.

## Production checklist
| Item | Action |
| ---- | ------ |
| Migrations | Run `npx flowra migrate` on deployment. |
| Health checks | Expose `/health` endpoint; configure load balancer to poll it. |
| Backups | Schedule database backups aligned with RPO/RTO. |
| Secrets | Rotate API keys and database passwords regularly. |
| Observability | Set up alerts on error rate, latency, queue depth. |

## Scaling strategies
- **Horizontal scaling** – run multiple instances behind a load balancer; enable sticky sessions if using stateful auth.
- **Database pooling** – tune `DB_POOL_MIN`/`DB_POOL_MAX` based on connection limits.
- **Background jobs** – offload heavy tasks to queues using providers defined in `core/queues`.
- **Static assets** – serve via CDN or object storage instead of the Node process.

> **note**
> Keep a staging environment mirroring production to validate migrations, caching, and service container wiring before rolling out.
