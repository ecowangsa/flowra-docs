---
id: first-api
slug: /getting-started/first-api
sidebar_position: 3
---

# Build Your First API

## Goal
Create a `GET /health` and `POST /users` endpoint backed by a service and validator. We will rely on the module generator so the structure matches the conventions shipped in the Flowra source repository.

## 1. Generate the module
```bash
npx flowra make:module users
```

The command creates `app/modules/users` containing:

```text
users/
├─ http/
│  ├─ controllers/
│  │  └─ users.controller.ts
│  ├─ requests/
│  │  └─ create-user.request.ts
│  └─ routes.ts
├─ services/
│  └─ user.service.ts
└─ index.ts
```

## 2. Implement the controller
`app/modules/users/http/controllers/users.controller.ts` orchestrates request validation and calls the service container.

```ts
import {Request, Response} from 'express';
import {container} from '../../../../core/container/application-container';
import {UserService} from '../../services/user.service';
import {CreateUserRequest} from '../requests/create-user.request';

export class UsersController {
  async health(req: Request, res: Response) {
    res.json({status: 'ok'});
  }

  async store(req: Request, res: Response) {
    const payload = await CreateUserRequest.validate(req.body);
    const service = container.resolve(UserService);
    const user = await service.create(payload);
    return res.status(201).json(user);
  }
}
```

> **note**
> Controllers stay thin—no database access or business branching here. Delegate everything to services.

## 3. Validate input
`app/modules/users/http/requests/create-user.request.ts` centralises schema validation using the validation utilities exposed via `core/http/validation`.

```ts
import {z} from 'zod';
import {ValidationException} from '../../../../core/http/exceptions/validation-exception';

const schema = z.object({
  email: z.string().email(),
  name: z.string().min(2),
});

export class CreateUserRequest {
  static async validate(body: unknown) {
    const parsed = schema.safeParse(body);
    if (!parsed.success) {
      throw new ValidationException(parsed.error.flatten());
    }
    return parsed.data;
  }
}
```

## 4. Implement the service
`app/modules/users/services/user.service.ts` depends on the model layer.

```ts
import {injectable} from '../../../core/container/decorators';
import {UserModel} from '../models/user.model';

@injectable()
export class UserService {
  constructor(private readonly users: UserModel) {}

  async create(payload: {email: string; name: string}) {
    const existing = await this.users.findByEmail(payload.email);
    if (existing) {
      throw new Error('Email already exists');
    }
    return this.users.insert(payload);
  }
}
```

## 5. Register routes
`app/modules/users/http/routes.ts` wires Express routers to controller actions.

```ts
import {Router} from 'express';
import {UsersController} from './controllers/users.controller';

const router = Router();
const controller = new UsersController();

router.get('/health', controller.health.bind(controller));
router.post('/users', controller.store.bind(controller));

export default router;
```

Finally hook the module inside `app/modules/users/index.ts`:

```ts
import routes from './http/routes';

export const UsersModule = {
  basePath: '/',
  routes,
};
```

Update `main/bootstrap.ts` to register the module:

```ts
import {UsersModule} from '../app/modules/users';

app.registerModule(UsersModule);
```

## 6. Run the application
```bash
npx flowra serve --watch
```

Check the health endpoint:

```bash
curl http://localhost:3000/health
```

Create a user:

```bash
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"email":"ada@example.com","name":"Ada"}'
```

## 7. Common mistakes
> **warning**
> Forgetting to bind controller methods results in `this` being undefined inside the handler. Always call `.bind(controller)` or use arrow functions.

- Missing dependency registration in the service container. Confirm that `UserModel` is registered inside `app/modules/users/providers.ts` or `core/container/providers.ts`.
- Throwing raw errors without mapping them via `core/http/response/error-handler.ts` leads to 500 responses. Extend the HTTP exception classes instead.
- Skipping validation means downstream services have to guard against malformed data. Keep validators next to the request definitions.
