---
id: service-container
slug: /architecture/service-container
sidebar_position: 6
---

# Service Container & Dependency Injection

## Why a container?
Flowra applications grow quickly. Manual `require` chains or ad-hoc singletons create hidden dependencies and complicate testing. The service container centralises object creation, lifetime management, and dependency graphs.

## Building blocks
- **Container** – `core/container/application-container.ts` exports the singleton instance.
- **Decorators** – `@injectable()` marks a class as resolvable; `@inject(Token)` requests a specific binding.
- **Providers** – `core/container/providers.ts` and `app/providers/index.ts` register bindings.
- **Context** – each HTTP request can resolve scoped services using `container.createChildContext()` when isolation is needed.

## Registering services
Declare your service and register it inside the module provider.

```ts
// app/modules/users/services/user.service.ts
import {injectable} from '../../../core/container/decorators';
import {UserModel} from '../models/user.model';

@injectable()
export class UserService {
  constructor(private readonly users: UserModel) {}

  async create(payload: {email: string; name: string}) {
    return this.users.insert(payload);
  }
}
```

```ts
// app/modules/users/providers.ts
import {container} from '../../core/container/application-container';
import {UserService} from './services/user.service';
import {UserModel} from './models/user.model';

export function registerUserModule() {
  container.singleton(UserService, UserService);
  container.singleton(UserModel, UserModel);
}
```

Call the provider from `app/providers/index.ts` so it runs during bootstrap.

## Resolving dependencies
Controllers, middlewares, and other services request dependencies by type.

```ts
// app/modules/users/http/controllers/users.controller.ts
import {Request, Response} from 'express';
import {container} from '../../../../core/container/application-container';
import {UserService} from '../../services/user.service';

export class UsersController {
  async store(req: Request, res: Response) {
    const service = container.resolve(UserService);
    const user = await service.create(req.body);
    res.status(201).json(user);
  }
}
```

For constructor injection between services:

```ts
@injectable()
export class InviteUserService {
  constructor(
    private readonly users: UserService,
    @inject('MailClient') private readonly mailer: MailClient,
  ) {}
}
```

## Testing with the container
> **tip**
> Use `core/testing/application-test-module.ts` to boot a lightweight container for unit and integration tests.

```ts
import {createTestApplication} from '../../core/testing/application-test-module';

const app = await createTestApplication({
  modules: [UsersModule],
  overrides: [
    {
      token: 'MailClient',
      useValue: fakeMailer,
    },
  ],
});

const service = app.container.resolve(UserService);
```

## Benefits
- **Testability** – swap dependencies with mocks during tests.
- **Decoupling** – services depend on interfaces, not concrete implementations.
- **Lifecycle control** – configure singleton vs. transient vs. scoped lifetimes.
- **Discoverability** – central provider files document what each module exports.

## Anti-patterns
> **warning**
> Avoid calling `new` directly inside controllers or services. Doing so bypasses the container, hides dependencies, and breaks lifecycle management.

- Registering everything as a singleton when it holds per-request state.
- Using container resolution inside constructors (`container.resolve()` in the class body). Prefer constructor parameters.
- Hiding complex logic inside provider functions instead of in dedicated factory classes.
