---
id: recipes
slug: /recipes
sidebar_position: 16
---

# Recipes

## Pagination API
**Problem:** You need consistent pagination responses across modules.

**Solution:** Use the Knex pagination plugin and wrap the result in a DTO.

```ts
// app/modules/users/services/list-users.service.ts
import {injectable} from '../../../core/container/decorators';
import {UserModel} from '../models/user.model';

@injectable()
export class ListUsersService {
  constructor(private readonly users: UserModel) {}

  async execute(page = 1, perPage = 25) {
    const result = await this.users.findAll(page, perPage);
    return {
      data: result.data,
      meta: result.pagination,
    };
  }
}
```

Expose metadata in the controller:

```ts
res.json({data: users.data, meta: users.meta});
```

## File upload via S3
**Problem:** Accept files and stream them to object storage without blocking the event loop.

**Solution:** Use the upload middleware and S3 client registered in the container.

```ts
// app/modules/files/http/controllers/uploads.controller.ts
import {Request, Response} from 'express';
import {S3Client} from '@aws-sdk/client-s3';
import {container} from '../../../../core/container/application-container';

export class UploadsController {
  async store(req: Request, res: Response) {
    const file = req.file!; // multer injects file
    const s3 = container.resolve<S3Client>('S3Client');

    await s3.putObject({
      Bucket: process.env.AWS_BUCKET!,
      Key: `uploads/${file.originalname}`,
      Body: file.buffer,
      ContentType: file.mimetype,
    });

    res.status(201).json({path: `uploads/${file.originalname}`});
  }
}
```

Register middleware:

```ts
router.post('/uploads', upload.single('file'), controller.store.bind(controller));
```

## Background jobs
**Problem:** Offload long-running operations (email, report generation).

**Solution:** Use the queue provider defined in `core/queues/bullmq.provider.ts`.

```ts
// app/modules/reports/services/report-job.service.ts
import {injectable, inject} from '../../../core/container/decorators';
import {Queue} from 'bullmq';

@injectable()
export class ReportJobService {
  constructor(@inject('Queues.reports') private readonly queue: Queue) {}

  async enqueue(payload: {reportId: string}) {
    await this.queue.add('generate-report', payload, {
      attempts: 3,
      backoff: {type: 'exponential', delay: 5000},
    });
  }
}
```

Worker example:

```ts
// app/modules/reports/workers/report.worker.ts
import {workerFactory} from '../../../core/queues/worker.factory';

export default workerFactory('Queues.reports', async job => {
  // generate report
});
```

## Caching responses
**Problem:** Reduce load on expensive queries.

**Solution:** Register a cache provider (Redis) and wrap service calls.

```ts
@injectable()
export class CachedProductService {
  constructor(
    private readonly products: ProductModel,
    @inject('CacheManager') private readonly cache: CacheManager,
  ) {}

  async getById(id: string) {
    return this.cache.remember(`products:${id}`, 60, () => this.products.findById(id));
  }
}
```

## CLI automation for releases
**Problem:** Ensure releases bump versions and generate changelogs.

**Solution:** Create a custom CLI command that wraps your release process.

```ts
export default new Command('release')
  .description('Cut a release with changelog')
  .action(async ({shell}) => {
    await shell.run('npm run lint');
    await shell.run('npm test');
    await shell.run('changeset version');
    await shell.run('git push --follow-tags');
  });
```
