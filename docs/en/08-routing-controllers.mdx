---
id: routing-controllers
slug: /modules/routing-controllers
sidebar_position: 8
---

# Routing & Controllers

## Defining routes
Routes live alongside controllers in each module under `http/routes.ts`. Flowra uses Express routers but wraps registration to enforce consistent prefixes.

```ts
import {Router} from 'express';
import {UsersController} from './controllers/users.controller';

const router = Router();
const controller = new UsersController();

router.get('/', controller.index.bind(controller));
router.get('/:id', controller.show.bind(controller));
router.post('/', controller.store.bind(controller));

export default router;
```

Register the router in `index.ts`:

```ts
export const UsersModule = {
  basePath: '/users',
  routes,
  middlewares: [],
};
```

## Controller structure
Controllers focus on orchestrating dependencies, not performing heavy logic.

```ts
export class UsersController {
  constructor(private readonly service = container.resolve(UserService)) {}

  async index(req: Request, res: Response) {
    const users = await this.service.list();
    res.json(users);
  }

  async show(req: Request, res: Response) {
    const user = await this.service.getById(req.params.id);
    if (!user) {
      throw new NotFoundHttpException('User not found');
    }
    res.json(user);
  }

  async store(req: Request, res: Response) {
    const payload = await CreateUserRequest.validate(req.body);
    const user = await this.service.create(payload);
    res.status(201).json(user);
  }
}
```

## Parameter extraction & validation
> **tip**
> Keep validation in dedicated request classes or Zod schemas stored under `http/requests`.

- Extract path params with `req.params` and validate using helpers.
- Parse query params via `req.query` and normalise using typed DTOs.
- Use the validation exception classes to send consistent 422 responses.

## Consistent responses
- Return JSON using `res.json()` or Flowra's `JsonResponse` helper.
- Throw `HttpException` subclasses for predictable error mapping (`BadRequestHttpException`, `UnauthorizedHttpException`).
- Set correct HTTP status codes: `201 Created` for POST, `204 No Content` for deletes, `202 Accepted` for async jobs.

## Designing REST endpoints
> **warning**
> Avoid overloading a single route with multiple responsibilities. Split read vs. write operations into separate controllers when complexity grows.

Checklist:

- [ ] Use nouns for resource paths (`/users`, `/orders/:id/items`).
- [ ] Keep controllers idempotent for GET, PUT, DELETE.
- [ ] Return pagination metadata (`total`, `page`, `perPage`) in list endpoints.
- [ ] Encapsulate business logic inside services, not controllers.
- [ ] Log request context (requestId, userId) before calling services.

## Error handling
Flowra ships with `core/http/responses/error-handler.ts` that maps exceptions. Throw structured errors:

```ts
throw new ValidationException({email: ['Email already taken']});
```

Override the default behaviour by registering a custom error handler middleware in `core/http/kernel.ts`.
