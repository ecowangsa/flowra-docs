---
id: first-api
slug: /getting-started/first-api
sidebar_position: 3
---

# Membangun API Pertama Anda

## Tujuan
Membuat endpoint `GET /health` dan `POST /users` yang ditopang oleh service serta validator. Kita akan memanfaatkan generator modul agar strukturnya sesuai konvensi yang tersedia di repositori sumber Flowra.

## 1. Membuat modul
```bash
npx flowra make:module users
```

Perintah tersebut membuat `app/modules/users` dengan isi:

```text
users/
├─ http/
│  ├─ controllers/
│  │  └─ users.controller.ts
│  ├─ requests/
│  │  └─ create-user.request.ts
│  └─ routes.ts
├─ services/
│  └─ user.service.ts
└─ index.ts
```

## 2. Implementasi controller
`app/modules/users/http/controllers/users.controller.ts` mengatur validasi request dan memanggil service lewat container.

```ts
import {Request, Response} from 'express';
import {container} from '../../../../core/container/application-container';
import {UserService} from '../../services/user.service';
import {CreateUserRequest} from '../requests/create-user.request';

export class UsersController {
  async health(req: Request, res: Response) {
    res.json({status: 'ok'});
  }

  async store(req: Request, res: Response) {
    const payload = await CreateUserRequest.validate(req.body);
    const service = container.resolve(UserService);
    const user = await service.create(payload);
    return res.status(201).json(user);
  }
}
```

> **note**
> Controller harus tetap tipis—tidak ada akses database atau logika bisnis yang bercabang. Delegasikan semuanya ke service.

## 3. Validasi input
`app/modules/users/http/requests/create-user.request.ts` memusatkan validasi skema dengan utilitas yang tersedia di `core/http/validation`.

```ts
import {z} from 'zod';
import {ValidationException} from '../../../../core/http/exceptions/validation-exception';

const schema = z.object({
  email: z.string().email(),
  name: z.string().min(2),
});

export class CreateUserRequest {
  static async validate(body: unknown) {
    const parsed = schema.safeParse(body);
    if (!parsed.success) {
      throw new ValidationException(parsed.error.flatten());
    }
    return parsed.data;
  }
}
```

## 4. Implementasi service
`app/modules/users/services/user.service.ts` bergantung pada lapisan model.

```ts
import {injectable} from '../../../core/container/decorators';
import {UserModel} from '../models/user.model';

@injectable()
export class UserService {
  constructor(private readonly users: UserModel) {}

  async create(payload: {email: string; name: string}) {
    const existing = await this.users.findByEmail(payload.email);
    if (existing) {
      throw new Error('Email already exists');
    }
    return this.users.insert(payload);
  }
}
```

## 5. Mendaftarkan route
`app/modules/users/http/routes.ts` menghubungkan router Express dengan aksi controller.

```ts
import {Router} from 'express';
import {UsersController} from './controllers/users.controller';

const router = Router();
const controller = new UsersController();

router.get('/health', controller.health.bind(controller));
router.post('/users', controller.store.bind(controller));

export default router;
```

Terakhir kaitkan modul pada `app/modules/users/index.ts`:

```ts
import routes from './http/routes';

export const UsersModule = {
  basePath: '/',
  routes,
};
```

Perbarui `main/bootstrap.ts` untuk mendaftarkan modul:

```ts
import {UsersModule} from '../app/modules/users';

app.registerModule(UsersModule);
```

## 6. Menjalankan aplikasi
```bash
npx flowra serve --watch
```

Uji endpoint health:

```bash
curl http://localhost:3000/health
```

Buat pengguna baru:

```bash
curl -X POST http://localhost:3000/users \
  -H "Content-Type: application/json" \
  -d '{"email":"ada@example.com","name":"Ada"}'
```

## 7. Kesalahan umum
> **warning**
> Lupa melakukan `.bind(controller)` membuat `this` di dalam handler menjadi `undefined`. Selalu ikat method atau gunakan arrow function.

- Dependensi belum terdaftar di service container. Pastikan `UserModel` terdaftar di `app/modules/users/providers.ts` atau `core/container/providers.ts`.
- Melempar error mentah tanpa memetakannya lewat `core/http/response/error-handler.ts` akan menghasilkan respons 500. Gunakan kelas exception HTTP bawaan.
- Melewatkan validasi membuat service hilir harus menjaga data yang tidak valid. Letakkan validator di sebelah definisi request.
