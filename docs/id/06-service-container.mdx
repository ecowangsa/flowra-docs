---
id: service-container
slug: /architecture/service-container
sidebar_position: 6
---

# Service Container & Dependency Injection

## Mengapa butuh container?
Aplikasi Flowra berkembang cepat. Rantai `require` manual atau singleton acak menciptakan dependensi tersembunyi dan mempersulit testing. Service container memusatkan pembuatan objek, manajemen lifecycle, serta grafik dependensi.

## Komponen utama
- **Container** – `core/container/application-container.ts` mengekspor instance tunggal.
- **Dekorator** – `@injectable()` menandai kelas agar bisa di-resolve; `@inject(Token)` meminta binding tertentu.
- **Provider** – `core/container/providers.ts` dan `app/providers/index.ts` mendaftarkan binding.
- **Context** – setiap request HTTP bisa me-resolve service scoped memakai `container.createChildContext()` bila butuh isolasi.

## Mendaftarkan service
Deklarasikan service dan daftar di provider modul.

```ts
// app/modules/users/services/user.service.ts
import {injectable} from '../../../core/container/decorators';
import {UserModel} from '../models/user.model';

@injectable()
export class UserService {
  constructor(private readonly users: UserModel) {}

  async create(payload: {email: string; name: string}) {
    return this.users.insert(payload);
  }
}
```

```ts
// app/modules/users/providers.ts
import {container} from '../../core/container/application-container';
import {UserService} from './services/user.service';
import {UserModel} from './models/user.model';

export function registerUserModule() {
  container.singleton(UserService, UserService);
  container.singleton(UserModel, UserModel);
}
```

Panggil provider tersebut dari `app/providers/index.ts` agar berjalan saat bootstrap.

## Me-resolve dependensi
Controller, middleware, dan service lain meminta dependensi berdasarkan tipe.

```ts
// app/modules/users/http/controllers/users.controller.ts
import {Request, Response} from 'express';
import {container} from '../../../../core/container/application-container';
import {UserService} from '../../services/user.service';

export class UsersController {
  async store(req: Request, res: Response) {
    const service = container.resolve(UserService);
    const user = await service.create(req.body);
    res.status(201).json(user);
  }
}
```

Untuk injection antar service:

```ts
@injectable()
export class InviteUserService {
  constructor(
    private readonly users: UserService,
    @inject('MailClient') private readonly mailer: MailClient,
  ) {}
}
```

## Testing dengan container
> **tip**
> Gunakan `core/testing/application-test-module.ts` untuk menyalakan container ringan bagi unit maupun integration test.

```ts
import {createTestApplication} from '../../core/testing/application-test-module';

const app = await createTestApplication({
  modules: [UsersModule],
  overrides: [
    {
      token: 'MailClient',
      useValue: fakeMailer,
    },
  ],
});

const service = app.container.resolve(UserService);
```

## Manfaat
- **Testability** – ganti dependensi dengan mock saat pengujian.
- **Decoupling** – service bergantung pada antarmuka, bukan implementasi konkret.
- **Kontrol lifecycle** – atur singleton vs. transient vs. scoped sesuai kebutuhan.
- **Discoverability** – berkas provider mendokumentasikan apa yang diekspor modul.

## Anti-pattern
> **warning**
> Hindari memanggil `new` langsung di controller atau service. Hal itu melewati container, menyembunyikan dependensi, dan merusak pengelolaan lifecycle.

- Mendaftarkan semua sebagai singleton padahal menyimpan state per request.
- Memakai `container.resolve()` di dalam konstruktor kelas. Lebih baik gunakan parameter konstruktor.
- Menyembunyikan logika kompleks di fungsi provider alih-alih di kelas factory khusus.
