---
id: routing-controllers
slug: /modules/routing-controllers
sidebar_position: 8
---

# Routing & Controller

## Mendefinisikan route
Route berada di samping controller dalam setiap modul, tepatnya pada `http/routes.ts`. Flowra memakai router Express namun membungkus registrasi agar prefix tetap konsisten.

```ts
import {Router} from 'express';
import {UsersController} from './controllers/users.controller';

const router = Router();
const controller = new UsersController();

router.get('/', controller.index.bind(controller));
router.get('/:id', controller.show.bind(controller));
router.post('/', controller.store.bind(controller));

export default router;
```

Daftarkan router tersebut di `index.ts`:

```ts
export const UsersModule = {
  basePath: '/users',
  routes,
  middlewares: [],
};
```

## Struktur controller
Controller fokus mengorkestrasi dependensi, bukan menjalankan logika berat.

```ts
export class UsersController {
  constructor(private readonly service = container.resolve(UserService)) {}

  async index(req: Request, res: Response) {
    const users = await this.service.list();
    res.json(users);
  }

  async show(req: Request, res: Response) {
    const user = await this.service.getById(req.params.id);
    if (!user) {
      throw new NotFoundHttpException('User not found');
    }
    res.json(user);
  }

  async store(req: Request, res: Response) {
    const payload = await CreateUserRequest.validate(req.body);
    const user = await this.service.create(payload);
    res.status(201).json(user);
  }
}
```

## Ekstraksi parameter & validasi
> **tip**
> Simpan validasi dalam kelas request khusus atau skema Zod di folder `http/requests`.

- Ambil path parameter lewat `req.params` lalu validasi dengan helper.
- Parse query parameter via `req.query` dan normalisasi menggunakan DTO bertipe.
- Gunakan kelas exception validasi agar respon 422 konsisten.

## Respons yang konsisten
- Kembalikan JSON menggunakan `res.json()` atau helper `JsonResponse` Flowra.
- Lempar turunan `HttpException` untuk pemetaan error yang bisa diprediksi (`BadRequestHttpException`, `UnauthorizedHttpException`).
- Tetapkan status HTTP yang tepat: `201 Created` untuk POST, `204 No Content` untuk delete, `202 Accepted` untuk job async.

## Mendesain endpoint REST
> **warning**
> Jangan menjejalkan banyak tanggung jawab ke satu route. Pisahkan operasi read dan write ke controller berbeda saat kompleksitas meningkat.

Checklist:

- [ ] Gunakan kata benda untuk path resource (`/users`, `/orders/:id/items`).
- [ ] Jaga controller idempotent untuk GET, PUT, DELETE.
- [ ] Sertakan metadata paginasi (`total`, `page`, `perPage`) pada endpoint daftar.
- [ ] Bungkus logika bisnis di dalam service, bukan controller.
- [ ] Logging konteks request (requestId, userId) sebelum memanggil service.

## Penanganan error
Flowra menyertakan `core/http/responses/error-handler.ts` untuk memetakan exception. Lempar error terstruktur:

```ts
throw new ValidationException({email: ['Email already taken']});
```

Anda dapat menimpa perilaku default dengan mendaftarkan middleware error handler kustom di `core/http/kernel.ts`.
