---
title: 'Your First API'
description: 'Create a health check endpoint and a simple CRUD feature using Flowra modules, controllers, and services.'
---

In this tutorial you'll build two endpoints: a health check and a minimal task manager with create/list operations. We'll leverage Flowra's CLI, controllers, services, and models to wire everything together.

## 1. Scaffold a module

Generate a `tasks` module:

```bash
npx flowra make:module tasks
```

The generator creates controllers, services, a routes file, and test stubs under `app/modules/tasks`.

:::note Directory layout
```
app/modules/tasks/
├─ controllers/
│  └─ tasks-controller.ts
├─ services/
│  ├─ create-task-service.ts
│  └─ list-tasks-service.ts
├─ models/
│  └─ task-model.ts
└─ routes.ts
```
:::

## 2. Implement the health check

The scaffold already includes a `health` module similar to the one shown in [What is Flowra?](../overview/what-is-flowra). Ensure its controller returns uptime information:

```ts title="app/modules/health/services/health-service.ts"
import {injectable} from 'tsyringe';

@injectable()
export class HealthService {
  async getStatus() {
    return {
      status: 'ok',
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
    };
  }
}
```

With routes registered, a quick check verifies everything is wired correctly:

```bash
curl http://localhost:3000/health
# {"status":"ok","uptime":12.34,"timestamp":"2024-05-01T12:00:00.000Z"}
```

## 3. Create the task model

Open `app/modules/tasks/models/task-model.ts` and describe the table schema using Knex:

```ts title="app/modules/tasks/models/task-model.ts"
import {inject, injectable} from 'tsyringe';
import type {Knex} from 'knex';

@injectable()
export class TaskModel {
  constructor(@inject('database.default') private readonly db: Knex) {}

  table() {
    return this.db<TaskRecord>('tasks');
  }

  async create(payload: {title: string; completed?: boolean}) {
    const [task] = await this.table()
      .insert({...payload, completed: payload.completed ?? false})
      .returning(['id', 'title', 'completed', 'created_at']);
    return task;
  }

  async all() {
    return this.table().select('id', 'title', 'completed', 'created_at').orderBy('created_at', 'desc');
  }
}

export type TaskRecord = {
  id: string;
  title: string;
  completed: boolean;
  created_at: Date;
};
```

:::tip Database setup
Create a migration with `npx flowra make:migration create_tasks_table` and add columns `id`, `title`, `completed`, and timestamps. Run `npm run knex migrate:latest` after editing the migration file.
:::

## 4. Wire services and controller

Update the services generated by the CLI:

```ts title="app/modules/tasks/services/create-task-service.ts"
import {injectable} from 'tsyringe';
import {TaskModel} from '../models/task-model';

@injectable()
export class CreateTaskService {
  constructor(private readonly model: TaskModel) {}

  async execute(input: {title: string}) {
    return this.model.create({title: input.title});
  }
}
```

```ts title="app/modules/tasks/services/list-tasks-service.ts"
import {injectable} from 'tsyringe';
import {TaskModel} from '../models/task-model';

@injectable()
export class ListTasksService {
  constructor(private readonly model: TaskModel) {}

  async execute() {
    return this.model.all();
  }
}
```

Adjust the controller to call both services:

```ts title="app/modules/tasks/controllers/tasks-controller.ts"
import {injectable} from 'tsyringe';
import type {Request, Response} from 'express';
import {CreateTaskService} from '../services/create-task-service';
import {ListTasksService} from '../services/list-tasks-service';

@injectable()
export class TasksController {
  constructor(
    private readonly createTask: CreateTaskService,
    private readonly listTasks: ListTasksService,
  ) {}

  async index(req: Request, res: Response) {
    const tasks = await this.listTasks.execute();
    return res.json({data: tasks});
  }

  async store(req: Request, res: Response) {
    const task = await this.createTask.execute({title: req.body.title});
    return res.status(201).json({data: task});
  }
}
```

Update `routes.ts` to expose the endpoints:

```ts title="app/modules/tasks/routes.ts"
import {Router} from 'express';
import {useController} from '../../core/http/controller-resolver';
import {TasksController} from './controllers/tasks-controller';

export const registerTaskRoutes = (router: Router) => {
  router.get('/tasks', useController(TasksController, 'index'));
  router.post('/tasks', useController(TasksController, 'store'));
};
```

Register the module in `main/bootstrap.ts`:

```ts
import {registerTaskRoutes} from '../app/modules/tasks/routes';

export const bootstrap = async () => {
  const app = await createHttpServer();
  app.registerRoutes(registerTaskRoutes);
  // ...
};
```

## 5. Exercise the API

```bash
# Create a task
curl -X POST http://localhost:3000/tasks \
  -H 'Content-Type: application/json' \
  -d '{"title":"Write Flowra docs"}'

# List tasks
curl http://localhost:3000/tasks
```

Expected response:

```json
{
  "data": [
    {
      "id": "01HXYZ...",
      "title": "Write Flowra docs",
      "completed": false,
      "created_at": "2024-05-01T12:00:00.000Z"
    }
  ]
}
```

## Common mistakes

- Forgetting to register the module's routes in `main/bootstrap.ts`.
- Not binding the model/service in the container (the CLI handles this automatically; keep the generated `index.ts` exports).
- Skipping request validation—add a validator in `validators/` or wrap the controller with middleware.
- Running migrations against the wrong database URL.

:::warning Debugging dependency errors
A `ResolutionError` from `tsyringe` means the container cannot resolve a dependency. Ensure the class is decorated with `@injectable()` and that constructor parameters either use injectable classes or explicit `@inject` tokens.
:::

You now have a working module. Continue refining it with validation and tests using the [Testing Strategy](../testing/strategy) guide.
